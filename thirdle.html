<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Thirdle ‚Äì 3-Letter Word Game</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <link rel="stylesheet" href="common.css" />
  <script src="activity-logger.js"></script>
  <style>
    .board {
      grid-template-columns: repeat(3, 1fr);
      max-width: min(240px, 50vw);
    }
  </style>
</head>
<body>
  <div class="game">
    <header>
      <a href="index.html" class="home-link" title="Back to games (H)">üè†</a>
      <h1>Thirdle</h1>
      <small>Guess the three-letter word in six tries</small>
    </header>

    <main>
      <div class="board-wrapper" id="boardWrapper">
        <div id="board" class="board" aria-label="Game board"></div>
      </div>
      <div id="message" class="message" aria-live="polite"></div>
    </main>

    <div id="keyboard" class="keyboard" aria-label="On-screen keyboard"></div>
    <button id="new-game" type="button">New game</button>
    <div id="word-info" class="word-info" aria-live="polite"></div>
    <div id="word-info-entries" class="word-info-entries" aria-live="polite"></div>
  </div>

  <script>
    // British English 3-letter words from Hunspell en_GB dictionary (660 words)
    const WORD_LIST = [
      "ABS","ACE","ACT","ADD","ADO","ADS","AGA","AGE","AHA","AID","AIL","AIM","AIR","ALB","ALE",
      "ALL","ALP","AMP","AND","ANS","ANT","APE","APP","APT","ARC","ARE","ARK","ARM","ARR","ART",
      "ASH","ASK","ASP","ASS","ATE","AUK","AVE","AWE","AWK","AWL","AWN","AXE","AYE","BAA","BAD",
      "BAG","BAH","BAN","BAP","BAR","BAS","BAT","BAY","BED","BEE","BEG","BEN","BET","BHP","BIB",
      "BID","BIG","BIN","BIO","BIT","BIZ","BOA","BOB","BOD","BOG","BOO","BOP","BOT","BOW","BOX",
      "BOY","BRA","BRO","BUD","BUG","BUM","BUN","BUR","BUS","BUT","BUY","BYE","CAB","CAD","CAM",
      "CAN","CAP","CAR","CAT","CAW","CAY","CEP","CHA","CHG","CHI","CIG","COB","COD","COG","COL",
      "CON","COO","COP","COS","COT","COW","COX","COY","CRY","CUB","CUD","CUE","CUL","CUM","CUP",
      "CUR","CUT","DAB","DAD","DAM","DAN","DAP","DAY","DEB","DEE","DEG","DEN","DEV","DEW","DID",
      "DIE","DIG","DIM","DIN","DIP","DIS","DOC","DOE","DOG","DOH","DON","DOS","DOT","DOX","DRY",
      "DUB","DUD","DUE","DUG","DUN","DUO","DYE","DZO","EAR","EAT","EBB","ECU","EDS","EEL","EGG",
      "EGO","EKE","ELD","ELF","ELK","ELL","ELM","EMF","EMO","EMU","ENC","END","ERA","ERG","ERK",
      "ERR","ESP","EST","EVE","EWE","EYE","FAB","FAD","FAG","FAN","FAR","FAT","FAX","FAY","FED",
      "FEE","FEM","FEN","FER","FEW","FEY","FEZ","FIB","FIE","FIG","FIN","FIR","FIT","FIX","FLU",
      "FLY","FOB","FOE","FOG","FOL","FOO","FOP","FOX","FRO","FRY","FUG","FUN","FUR","GAB","GAD",
      "GAG","GAL","GAP","GAS","GAY","GCD","GEE","GEL","GEM","GEN","GEO","GET","GIB","GIG","GIN",
      "GIT","GNU","GOB","GOD","GOO","GOY","GUM","GUN","GUT","GUY","GYM","GYP","HAD","HAG","HAM",
      "HAP","HAT","HAW","HAY","HEM","HEN","HEP","HER","HEW","HEX","HID","HIE","HIP","HIS","HIT",
      "HOB","HOD","HOE","HOG","HOP","HOS","HOT","HOW","HOY","HUB","HUE","HUG","HUH","HUI","HUM",
      "HUT","ICE","ICY","ILL","IMP","INK","INN","ION","IRE","IRK","ISM","IVY","JAB","JAG","JAM",
      "JAR","JAW","JAY","JET","JIB","JIG","JOB","JOG","JOT","JOY","JPG","JUG","JUT","KEA","KEG",
      "KEN","KEY","KID","KIF","KIN","KIP","KIT","KYU","LAB","LAC","LAD","LAG","LAH","LAM","LAP",
      "LAW","LAX","LAY","LEA","LEE","LEG","LEI","LET","LEY","LEZ","LIB","LID","LIE","LIP","LIT",
      "LOB","LOG","LOO","LOP","LOT","LOW","LUG","LUX","LYE","MAC","MAD","MAG","MAN","MAP","MAR",
      "MAS","MAT","MAW","MAX","MAY","MEN","MES","MET","MEW","MFR","MIC","MID","MIN","MIX","MOB",
      "MOD","MOG","MOO","MOP","MOS","MOW","MUD","MUG","MUM","MUS","MUX","NAB","NAG","NAN","NAP",
      "NAY","NED","NEG","NEK","NET","NEW","NIB","NIL","NIP","NIT","NIX","NOB","NOD","NON","NOT",
      "NUB","NUN","NUT","OAF","OAK","OAR","OAT","ODD","ODE","OFF","OHM","OHO","OIK","OIL","OLD",
      "ONE","OOF","OOH","OPE","OPT","ORB","ORC","ORE","ORG","OUD","OUR","OUT","OVA","OWE","OWL",
      "OWN","PAD","PAL","PAN","PAP","PAR","PAS","PAT","PAW","PAY","PDF","PEA","PEE","PEG","PEN",
      "PEP","PER","PET","PEW","PHI","PHP","PIC","PIE","PIG","PIN","PIP","PIT","PIX","PLY","POD",
      "POO","POP","POT","POW","POX","PRE","PRO","PRY","PSI","PUB","PUG","PUN","PUP","PUS","PUT",
      "PUY","PYX","QUO","RAD","RAG","RAM","RAN","RAP","RAT","RAW","RAY","RED","REF","REG","REM",
      "REP","RET","REV","RHO","RIB","RID","RIG","RIM","RIP","ROB","ROD","ROE","ROT","ROW","RUB",
      "RUE","RUG","RUM","RUN","RUT","RYE","SAC","SAD","SAG","SAP","SAT","SAW","SAX","SAY","SEA",
      "SEC","SEE","SET","SEW","SEX","SHE","SHY","SIB","SIC","SIG","SIN","SIP","SIR","SIS","SIT",
      "SIX","SKI","SKY","SOB","SOD","SOL","SON","SOP","SOT","SOU","SOW","SOY","SPA","SPY","SSH",
      "STY","SUB","SUE","SUM","SUN","SUP","TAB","TAC","TAD","TAG","TAN","TAP","TAR","TAT","TAU",
      "TAW","TAX","TEA","TEC","TEE","TEN","THE","TIC","TIE","TIF","TIN","TIP","TIT","TOD","TOE",
      "TOG","TOM","TON","TOP","TOR","TOT","TOW","TOY","TRY","TUB","TUG","TUM","TUN","TUT","TWO",
      "UGH","URN","USE","VAN","VAT","VEG","VET","VEX","VID","VIE","VIG","VIM","VIS","VOL","VOW",
      "VUG","WAD","WAG","WAN","WAR","WAX","WAY","WEB","WED","WEE","WET","WHO","WIG","WIN","WIT",
      "WOE","WOG","WOK","WOO","WOP","WOW","WRY","XPI","XVI","YAH","YAK","YAM","YAP","YAW","YEA",
      "YEN","YEW","YIN","YIP","YOB","YUK","YUM","YUP","ZAG","ZAP","ZED","ZIP","ZIT","ZOO","ZUZ"
    ];

    const WORD_LENGTH = 3;
    const MAX_GUESSES = 6;

    let secretWord = "";
    let currentRow = 0;
    let currentCol = 0;
    let isGameOver = false;

    // Activity logging
    let sessionId = null;
    let guessStartTime = null;
    const GAME_NAME = 'thirdle';

    const boardEl = document.getElementById("board");
    const boardWrapperEl = document.getElementById("boardWrapper");
    const messageEl = document.getElementById("message");
    const keyboardEl = document.getElementById("keyboard");
    const newGameBtn = document.getElementById("new-game");
    
    // For board centering
    let tileHeight = 0;
    let boardGap = 4;

    function centerCurrentRow() {
      if (!tileHeight) {
        const firstTile = getTile(0, 0);
        if (firstTile) {
          tileHeight = firstTile.offsetHeight;
          const boardStyle = getComputedStyle(boardEl);
          boardGap = parseFloat(boardStyle.gap) || 4;
        }
      }
      const rowHeight = tileHeight + boardGap;
      const offset = currentRow * rowHeight;
      boardWrapperEl.style.transform = `translateY(-${offset}px)`;
      updateRowOpacity();
    }
    
    function updateRowOpacity() {
      for (let r = 0; r < MAX_GUESSES; r++) {
        for (let c = 0; c < WORD_LENGTH; c++) {
          const tile = getTile(r, c);
          if (tile) {
            const rowDistance = currentRow - r;
            if (rowDistance > 3) {
              tile.dataset.faded = "true";
            } else {
              delete tile.dataset.faded;
            }
          }
        }
      }
    }

    function pickSecretWord() {
      const idx = Math.floor(Math.random() * WORD_LIST.length);
      return WORD_LIST[idx];
    }

    function createBoard() {
      boardEl.innerHTML = "";
      for (let row = 0; row < MAX_GUESSES; row++) {
        for (let col = 0; col < WORD_LENGTH; col++) {
          const tile = document.createElement("div");
          tile.className = "tile";
          tile.dataset.row = row;
          tile.dataset.col = col;
          boardEl.appendChild(tile);
        }
      }
    }

    function createKeyboard() {
      keyboardEl.innerHTML = "";
      const rows = ["QWERTYUIOP", "ASDFGHJKL", "ZXCVBNM"];

      rows.forEach((row, ri) => {
        const rowDiv = document.createElement("div");
        rowDiv.className = "keyboard-row";

        if (ri === 2) {
          const enter = makeKeyButton("ENTER");
          enter.classList.add("wide");
          rowDiv.appendChild(enter);
        }

        for (const ch of row) {
          rowDiv.appendChild(makeKeyButton(ch));
        }

        if (ri === 2) {
          const del = makeKeyButton("DEL");
          del.classList.add("wide");
          rowDiv.appendChild(del);
        }

        keyboardEl.appendChild(rowDiv);
      });
    }

    function makeKeyButton(label) {
      const btn = document.createElement("button");
      btn.type = "button";
      btn.className = "key";
      btn.textContent = label === "DEL" ? "‚å´" : label === "ENTER" ? "Enter" : label;
      btn.dataset.key = label;
      btn.addEventListener("click", () => handleKey(label));
      return btn;
    }

    function showMessage(text) {
      messageEl.textContent = text;
    }

    function shakeRow(row) {
      for (let col = 0; col < WORD_LENGTH; col++) {
        const tile = getTile(row, col);
        tile.classList.add("invalid");
        tile.addEventListener("animationend", () => {
          tile.classList.remove("invalid");
        }, { once: true });
      }
    }

    function getTile(row, col) {
      return boardEl.querySelector(`.tile[data-row="${row}"][data-col="${col}"]`);
    }

    function updateKeyboardColours(letterStatuses) {
      // letterStatuses: map from letter to status ("correct", "present", "absent")
      for (const [letter, status] of Object.entries(letterStatuses)) {
        const keyBtn = keyboardEl.querySelector(`.key[data-key="${letter}"]`);
        if (!keyBtn) continue;

        // Upgrade logic: correct > present > absent
        const current = keyBtn.dataset.status;
        if (current === "correct") continue;
        if (current === "present" && status === "absent") continue;

        keyBtn.dataset.status = status;
        keyBtn.classList.remove("correct", "present", "absent");
        keyBtn.classList.add(status);
      }
    }

    function handleKey(key) {
      if (isGameOver) return;

      if (key === "ENTER") {
        submitGuess();
      } else if (key === "DEL" || key === "Backspace") {
        deleteLetter();
      } else if (/^[A-Z]$/.test(key)) {
        addLetter(key);
      }
    }

    function addLetter(letter) {
      if (currentCol >= WORD_LENGTH) return;
      const tile = getTile(currentRow, currentCol);
      tile.textContent = letter;
      tile.classList.add("filled");
      currentCol += 1;
    }

    function deleteLetter() {
      if (currentCol === 0) return;
      currentCol -= 1;
      const tile = getTile(currentRow, currentCol);
      tile.textContent = "";
      tile.classList.remove("filled");
    }

    function submitGuess() {
      if (currentCol < WORD_LENGTH) {
        showMessage("Not enough letters");
        return;
      }

      let guess = "";
      for (let col = 0; col < WORD_LENGTH; col++) {
        guess += getTile(currentRow, col).textContent;
      }
      guess = guess.toUpperCase();

      if (!WORD_LIST.includes(guess)) {
        showMessage("Word not in list");
        shakeRow(currentRow);
        return;
      }

      // Calculate reaction time
      const reactionTimeMs = guessStartTime ? Date.now() - guessStartTime : null;
      guessStartTime = Date.now();

      // Evaluate guess
      const evaluation = evaluateGuess(guess, secretWord);
      const letterStatuses = {};

      for (let col = 0; col < WORD_LENGTH; col++) {
        const tile = getTile(currentRow, col);
        const status = evaluation[col];
        tile.classList.add(status, "flip");
        const letter = guess[col];

        // Track best status for keyboard
        const current = letterStatuses[letter];
        if (current === "correct") {
          // already the best
        } else if (current === "present" && status === "absent") {
          // ignore downgrade
        } else {
          letterStatuses[letter] = status;
        }
      }

      updateKeyboardColours(letterStatuses);
      showWordInfo(guess);

      const isCorrect = guess === secretWord;
      
      // Log the guess
      ActivityLogger.logAction(sessionId, GAME_NAME, 'guess', {
        guess,
        correct: isCorrect,
        evaluation: evaluation.join(','),
        attemptNumber: currentRow + 1,
        reactionTimeMs
      });

      if (isCorrect) {
        showMessage("Splendid! You've got it.");
        isGameOver = true;
        ActivityLogger.endSession(sessionId, GAME_NAME, {
          won: true,
          score: MAX_GUESSES - currentRow,
          attempts: currentRow + 1,
          targetWord: secretWord
        });
        return;
      }

      currentRow += 1;
      currentCol = 0;
      centerCurrentRow();

      if (currentRow >= MAX_GUESSES) {
        showMessage(`Unlucky ‚Äì the word was ${secretWord}`);
        isGameOver = true;
        ActivityLogger.endSession(sessionId, GAME_NAME, {
          won: false,
          score: 0,
          attempts: MAX_GUESSES,
          targetWord: secretWord
        });
      } else {
        showMessage("");
      }
    }

    function evaluateGuess(guess, secret) {
      const result = Array(WORD_LENGTH).fill("absent");
      const secretLetters = secret.split("");
      const guessLetters = guess.split("");

      // First pass: correct positions
      const letterCounts = {};
      for (let i = 0; i < WORD_LENGTH; i++) {
        const s = secretLetters[i];
        letterCounts[s] = (letterCounts[s] || 0) + 1;
      }

      for (let i = 0; i < WORD_LENGTH; i++) {
        if (guessLetters[i] === secretLetters[i]) {
          result[i] = "correct";
          letterCounts[guessLetters[i]] -= 1;
        }
      }

      // Second pass: present but misplaced
      for (let i = 0; i < WORD_LENGTH; i++) {
        if (result[i] === "correct") continue;
        const letter = guessLetters[i];
        if (letterCounts[letter] > 0) {
          result[i] = "present";
          letterCounts[letter] -= 1;
        }
      }

      return result;
    }


    // Word definitions data
    let wordData = {};
    
    // Load word definitions
    fetch('word-data/words3.json')
      .then(r => r.json())
      .then(data => { wordData = data; console.log('Loaded', Object.keys(data).length, 'word definitions'); })
      .catch(e => console.log('Could not load word data:', e));

    const wordInfoEl = document.getElementById("word-info");
    const wordInfoEntriesEl = document.getElementById("word-info-entries");
    
    // Track word info entries for each row
    let wordInfoByRow = {};

    function showWordInfo(word) {
      const row = currentRow;
      const info = wordData[word];
      if (!info) {
        wordInfoEl.innerHTML = '';
        return;
      }
      
      displayWordInfo(word, info, row);
    }
    
    function displayWordInfo(word, info, row) {
      let html = '<div class="word-title">' + word + '</div>';
      if (info.d) {
        html += '<div class="definition">' + escapeHtml(info.d) + '</div>';
      }
      if (info.e) {
        html += '<div class="etymology">' + escapeHtml(info.e) + '</div>';
      }
      wordInfoEl.innerHTML = html;
      
      if (window.innerWidth >= 1000) {
        createWordInfoEntry(word, info, row);
      }
    }
    
    function createWordInfoEntry(word, info, row) {
      const existingEntry = wordInfoEntriesEl.querySelector(`[data-row="${row}"]`);
      if (existingEntry) existingEntry.remove();
      
      const entry = document.createElement('div');
      entry.className = 'word-info-entry';
      entry.dataset.row = row;
      entry.classList.add(row % 2 === 0 ? 'right-side' : 'left-side');
      
      let html = '<div class="word-title">' + word + '</div>';
      if (info.d) html += '<div class="definition">' + escapeHtml(info.d) + '</div>';
      if (info.e) html += '<div class="etymology">' + escapeHtml(info.e) + '</div>';
      entry.innerHTML = html;
      
      positionWordInfoEntry(entry, row);
      wordInfoEntriesEl.appendChild(entry);
      requestAnimationFrame(() => entry.classList.add('visible'));
      wordInfoByRow[row] = entry;
    }
    
    function positionWordInfoEntry(entry, row) {
      const firstTile = getTile(row, 0);
      if (!firstTile) return;
      const tileRect = firstTile.getBoundingClientRect();
      entry.style.top = `${tileRect.top + tileRect.height / 2}px`;
      entry.style.transform = 'translateY(-50%)';
    }
    
    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    function resetGame() {
      secretWord = pickSecretWord();
      currentRow = 0;
      currentCol = 0;
      isGameOver = false;
      tileHeight = 0;
      createBoard();
      createKeyboard();
      showMessage("New game ‚Äì good luck!");
      wordInfoEl.innerHTML = '';
      wordInfoEntriesEl.innerHTML = '';
      wordInfoByRow = {};
      
      requestAnimationFrame(() => {
        centerCurrentRow();
      });
      
      // Start new logging session
      sessionId = ActivityLogger.startSession(GAME_NAME, {
        wordLength: WORD_LENGTH,
        maxGuesses: MAX_GUESSES
      });
      guessStartTime = Date.now();
    }

    // Physical keyboard support
    document.addEventListener("keydown", (event) => {
      const key = event.key;
      if (key === "Enter") {
        handleKey("ENTER");
      } else if (key === "Backspace" || key === "Delete") {
        handleKey("Backspace");
      } else if (key.toLowerCase() === "n" && isGameOver) {
        resetGame();
      } else if (key.toLowerCase() === "h" && isGameOver) {
        window.location.href = "index.html";
      } else {
        const upper = key.toUpperCase();
        if (/^[A-Z]$/.test(upper)) {
          handleKey(upper);
        }
      }
    });

    newGameBtn.addEventListener("click", resetGame);

    // Initialise
    resetGame();
  </script>
</body>
</html>
